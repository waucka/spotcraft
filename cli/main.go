package main

import (
	"os"
	"fmt"
	"time"
	"bufio"
	"strings"
	"net/http"
	"math/rand"
	"io/ioutil"
	"path/filepath"

	"github.com/go-openapi/strfmt"
	opruntime "github.com/go-openapi/runtime/client"
	"github.com/urfave/cli"
	"github.com/rakyll/statik/fs"
	_ "github.com/waucka/spotcraft/cli/statik"
	yaml "gopkg.in/yaml.v2"
	homedir "github.com/mitchellh/go-homedir"

	api "github.com/waucka/spotcraft/cli/client"
	op "github.com/waucka/spotcraft/cli/client/operations"
	models "github.com/waucka/spotcraft/cli/models"

	aws "github.com/aws/aws-sdk-go/aws"
	session "github.com/aws/aws-sdk-go/aws/session"
	ec2 "github.com/aws/aws-sdk-go/service/ec2"
	s3 "github.com/aws/aws-sdk-go/service/s3"
	route53domains "github.com/aws/aws-sdk-go/service/route53domains"
	s3manager "github.com/aws/aws-sdk-go/service/s3/s3manager"
	cf "github.com/aws/aws-sdk-go/service/cloudformation"
)

type Config struct {
	InstallRegion string `yaml:"install_region"`
	ArtifactBucket string `yaml:"artifact_bucket"`
	VpcCidrBlock string `yaml:"vpc_cidr_block"`
	VpcInternalDomain string `yaml:"vpc_internal_domain"`
	MinecraftAZ string `yaml:"minecraft_az"`
	ServerBucket string `yaml:"server_bucket"`
	DomainName string `yaml:"domain_name"`
}

var (
	sess *session.Session
	ec2Client *ec2.EC2
	s3Client *s3.S3
	cfClient *cf.CloudFormation
	r53dClient *route53domains.Route53Domains

	transport *opruntime.Runtime
	client *api.Spotcraft

	config *Config

	// In order to be valid, regions must support the following services:
	// - Cognito
	// - Lambda
	// - EC2
	// - S3
	// - CloudFormation
	InstallValidRegions = map[string]bool {
		"ap-south-1": true,
		"eu-west-2": true,
		"eu-west-1": true,
		"ap-northeast-2": true,
		"ap-northeast-1": true,
		"ap-southeast-1": true,
		"ap-southeast-2": true,
		"eu-central-1": true,
		"us-east-1": true,
		"us-east-2": true,
		"us-west-2": true,
	}
)

const ValidIdCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

func generateRandomIdentifier(n int) string {
    b := make([]byte, n)
    for i := range b {
        b[i] = ValidIdCharacters[rand.Intn(len(ValidIdCharacters))]
    }
    return string(b)
}

func configureCli(c *cli.Context) error {
	reader := bufio.NewReader(os.Stdin)

	fmt.Println("First, you need to select the AWS region where you want to install SpotCraft.")
	fmt.Println("The following regions are known to have the necessary services enabled.")
	for regionName, _ := range InstallValidRegions {
		fmt.Println(regionName)
	}
	fmt.Print("AWS Region: ")
	region, _ := reader.ReadString('\n')
	if _, ok := InstallValidRegions[region]; !ok {
		fmt.Printf("%s is not known to be a valid region for installation.  Consider using a different region.", region)
	}

	fmt.Println("Next, you may name the S3 bucket where installation artifacts will be stored.")
	fmt.Println("Just press Enter if you want it to be autogenerated.")
	fmt.Print("Artifact Bucket Name [autogenerate]: ")
	artifactBucket, _ := reader.ReadString('\n')
	if artifactBucket == "" || artifactBucket == "autogenerate" {
		artifactBucket = fmt.Sprintf("spotcraft-%s", generateRandomIdentifier(16))
		fmt.Printf("Generated bucket name: %s\n", artifactBucket)
	}

	fmt.Println("You may choose an IP address range (in CIDR format) for the VPC that will be created.")
	fmt.Println("Just press Enter if you are OK with the default.")
	fmt.Print("VPC CIDR [10.0.0.0/16]: ")
	vpcCidr, _ := reader.ReadString('\n')
	if vpcCidr == "" {
		vpcCidr = "10.0.0.0/16"
	}

	fmt.Println("You may choose a custom VPC internal domain.")
	fmt.Println("If you are unsure, press Enter to use the default.")
	fmt.Print("VPC Internal Domain [ec2.internal]: ")
	vpcDomain, _ := reader.ReadString('\n')
	if vpcDomain == "" {
		vpcDomain = "ec2.internal"
	}

	fmt.Printf("You may choose the availability zone within the %s region where Minecraft servers should run.", region)
	fmt.Println("Just press Enter if you want one to be chosen for you.")
	fmt.Print("Minecraft AZ [autoselect]: ")
	minecraftAz, _ := reader.ReadString('\n')
	if minecraftAz == "" || minecraftAz == "autoselect" {
		setup(c, region)
		zonesResult, err := ec2Client.DescribeAvailabilityZones(&ec2.DescribeAvailabilityZonesInput{})
		if err != nil {
			fmt.Println("Failed to get AZ information!")
			fmt.Printf("Error information: %v", err)
			return err
		}
		for _, zone := range zonesResult.AvailabilityZones {
			if *zone.State == "available" {
				minecraftAz = *zone.ZoneName
				break
			}
		}
		if minecraftAz == "" || minecraftAz == "autoselect" {
			fmt.Println("No availability zones are currently available!")
			fmt.Println("AWS may be having problems.")
			return fmt.Errorf("Failed to select an availability zone")
		}
	}

	fmt.Println("You may name the S3 bucket where server configurations will be stored.")
	fmt.Println("Just press Enter if you want it to be autogenerated.")
	fmt.Print("Artifact Bucket Name [autogenerate]: ")
	serverBucket, _ := reader.ReadString('\n')
	if serverBucket == "" || serverBucket == "autogenerate" {
		serverBucket = fmt.Sprintf("spotcraft-%s", generateRandomIdentifier(16))
		fmt.Printf("Generated bucket name: %s\n", serverBucket)
	}

	fmt.Println("You must provide the domain you want to use for your Minecraft servers.")
	fmt.Println("The authoritative nameservers for this domain must be configured,")
	fmt.Println("so you must own or otherwise control it.  You can order a domain through")
	fmt.Println("Route53 Domains, hover.com, or name.com.  Stay away from GoDaddy.")
	fmt.Println("If you have already created a hosted zone for this domain in Route53,")
	fmt.Println("please remove it before installing SpotCraft.")
	fmt.Println("Note: if you bought the domain through Route53 Domains, this program")
	fmt.Println("will configure the nameservers for you.")
	fmt.Print("Minecraft server domain: ")
	domainName, _ := reader.ReadString('\n')
	if domainName == "" {
		return fmt.Errorf("No domain name was provided")
	}
	// Add the trailing dot if it wasn't provided.
	if domainName[len(domainName)-1] != '.' {
		domainName = domainName + "."
	}

	config = &Config{
		InstallRegion: region,
		ArtifactBucket: artifactBucket,
		VpcCidrBlock: vpcCidr,
		VpcInternalDomain: vpcDomain,
		MinecraftAZ: minecraftAz,
		ServerBucket: serverBucket,
		DomainName: domainName,
	}

	homeDir, err := homedir.Dir()
	if err != nil {
		return err
	}
	configPath := filepath.Join(homeDir, ".spotcraft.yaml")
	configBytes, err := yaml.Marshal(config)
	if err != nil {
		return err
	}
	f, err := os.OpenFile(configPath, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	_, err = f.Write(configBytes)
	if err != nil {
		return err
	}

	return nil
}

func setup(c *cli.Context, regionOverride string) error {
	var region *string
	if regionOverride != "" {
		region = aws.String(regionOverride)
	}
	var err error
	sess, err = session.NewSession(&aws.Config{
		Region: region,
	})
	if err != nil {
		return err
	}
	ec2Client = ec2.New(sess)
	s3Client = s3.New(sess)
	cfClient = cf.New(sess)
	r53dClient = route53domains.New(sess)

	transport = opruntime.New("localhost", "", nil)
	client = api.New(transport, strfmt.Default)

	return nil
}

func loadConfig() error {
	homeDir, err := homedir.Dir()
	if err != nil {
		return err
	}
	configPath := filepath.Join(homeDir, ".spotcraft.yaml")
	configBytes, err := ioutil.ReadFile(configPath)
	if err != nil {
		if os.IsNotExist(err) {
			fmt.Println("SpotCraft is not configured.  Run this command before doing anything else:")
			fmt.Println()
			fmt.Println("spotcraft configure")
		}
		return err
	}

	var conf Config
	err = yaml.Unmarshal(configBytes, &conf)
	if err != nil {
		return err
	}

	config = &conf
	return nil
}

func uploadFileToS3(statikfs http.FileSystem, uploader *s3manager.Uploader, bucket, key, localkey string) error {
	f, err := statikfs.Open(localkey)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = uploader.Upload(&s3manager.UploadInput{
		Bucket: aws.String(bucket),
		Key: aws.String(key),
		Body: f,
	})
	if err != nil {
		return err
	}

	return nil
}

func installSpotCraft(c *cli.Context) error {
	reader := bufio.NewReader(os.Stdin)

	region := c.Parent().String("region")

	err := setup(c, region)
	if err != nil {
		return err
	}

	uploader := s3manager.NewUploader(sess)
	statikfs, err := fs.New()
	if err != nil {
		return err
	}

	err = uploadFileToS3(statikfs, uploader, config.ArtifactBucket, "spotcraft.template", "spotcraft.template")
	if err != nil {
		return err
	}

	err = uploadFileToS3(statikfs, uploader, config.ArtifactBucket, "api.json", "api.json")
	if err != nil {
		return err
	}

	lambdaFuncs := []string{
		"create_instance.zip",
		"create_server.zip",
		"delete_server.zip",
		"get_instances.zip",
		"get_servers.zip",
		"modify_server.zip",
		"shutdown_instance.zip",
		"signup_validation.zip",
	}

	for _, lambdaFunc := range lambdaFuncs {
		key := fmt.Sprintf("functions/%s", lambdaFunc)
		err = uploadFileToS3(statikfs, uploader, config.ArtifactBucket, key, key)
		if err != nil {
			return err
		}
	}

	result, err := cfClient.CreateStack(&cf.CreateStackInput{
		TemplateURL: aws.String(fmt.Sprintf("s3://%s/spotcraft.template", config.ArtifactBucket)),
		TimeoutInMinutes: aws.Int64(5),
		Tags: []*cf.Tag{
			{
				Key: aws.String("spotcraft"),
				Value: aws.String("true"),
			},
		},
		StackName: aws.String("spotcraft"),
		Capabilities: []*string {
			aws.String("CAPABILITY_IAM"),
			aws.String("CAPABILITY_NAMED_IAM"),
		},
		Parameters: []*cf.Parameter{
			{
				ParameterKey: aws.String("ArtifactBucketParameter"),
				ParameterValue: aws.String(config.ArtifactBucket),
				UsePreviousValue: aws.Bool(false),
			},
			{
				ParameterKey: aws.String("VpcCidrBlockParameter"),
				ParameterValue: aws.String(config.VpcCidrBlock),
				UsePreviousValue: aws.Bool(false),
			},
			{
				ParameterKey: aws.String("VpcInternalDomainParameter"),
				ParameterValue: aws.String(config.VpcInternalDomain),
				UsePreviousValue: aws.Bool(false),
			},
			{
				ParameterKey: aws.String("MinecraftAZParameter:"),
				ParameterValue: aws.String(config.MinecraftAZ),
				UsePreviousValue: aws.Bool(false),
			},
			{
				ParameterKey: aws.String("ServerBucketParameter"),
				ParameterValue: aws.String(config.ServerBucket),
				UsePreviousValue: aws.Bool(false),
			},
		},
	})
	if err != nil {
		return err
	}

	stackId := *result.StackId

	start := time.Now()
	for time.Now().Sub(start) < 6 * time.Minute {
		time.Sleep(15 * time.Second)
		result, err := cfClient.DescribeStacks(&cf.DescribeStacksInput{
			StackName: aws.String(stackId),
		})
		if err != nil {
			fmt.Printf("Failed to get stack status: %v\n", err)
			continue
		}
		if len(result.Stacks) == 0 {
			fmt.Printf("No stacks have ID %s...that doesn't make any sense.\n", stackId)
			continue
		}
		stack := result.Stacks[0]
		status := *stack.StackStatus
		fmt.Printf("Stack status: %s\n", status)
		if status == "CREATE_FAILED" {
			return fmt.Errorf("Failed to create stack!")
		} else if status == "CREATE_COMPLETE" {
			fmt.Printf("Stack creation complete!")
			for _, output := range stack.Outputs {
				if *output.OutputKey == "HostedZoneNameServers" {
					servers := strings.Split(*output.OutputValue, ",")
					r53dNameservers := make([]*route53domains.Nameserver, 0)
					for _, server := range servers {
						r53dNameservers = append(r53dNameservers,
							&route53domains.Nameserver{
								Name: aws.String(server),
							})
					}
					_, err := r53dClient.UpdateDomainNameservers(
						&route53domains.UpdateDomainNameserversInput{
							DomainName: aws.String(config.DomainName),
							Nameservers: r53dNameservers,
						},
					)
					if err != nil {
						fmt.Println("You must configure these nameservers as authoritative for your domain")
						fmt.Println("See your domain registrar's instructions for more information.")
						for _, server := range servers {
							fmt.Printf("\t%s\n", server)
						}
					} else {
						fmt.Printf("Nameserver configuration for %s complete!\n", config.DomainName)
						fmt.Println("It may take a while for this change to propagate throughout the DNS system.")
						fmt.Println("Wait a few hours before continuing, just to be sure.")
					}
				}
			}
			return nil
		}
	}

	return fmt.Errorf("Stack creation is still in progress after 6 minutes.  This should never happen!")
}

func main() {
	rand.Seed(time.Now().UnixNano())

	app := cli.NewApp()
	app.Name = "spotcraft"
	app.Usage = "Install, configure, and control SpotCraft"
	app.Flags = []cli.Flag{
		cli.StringFlag{
			Name:  "region",
			Usage: "API endpoint to connect to when requesting IDs",
		},
	}
	app.Commands = []cli.Command{
		{
			Name: "install",
			Usage: "Install SpotCraft in your AWS account",
			Action: installSpotCraft,
		},
		{
			Name: "configure",
			Usage: "Configure the spotcraft CLI tool",
			Action: configureCli,
		},
	}

	/*params := op.NewCreateInstanceParams()
	params.NewInstance = &models.NewInstance{
		Duration: 360,
		KeyName: "",
		ServerName: "dickbutt",
	}
	_, err = client.Operations.CreateInstance(params)
	if err != nil {
		panic(err)
	}*/
}
